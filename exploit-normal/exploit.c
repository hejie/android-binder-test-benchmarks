#include "lib/binder.h"

static uint16_t service[] = { 'B', 's', 'v', 'r' };  
int iterations = 3;
int id =3;

int client_parse_command(int id, unsigned char *buf, unsigned long size, inst_buf_t **pinst)
{
  unsigned char *p, *ep;
  unsigned int cmd;
  tdata_t *tdata;
  inst_buf_t *inst = NULL;
#ifdef INLINE_TRANSACTION_DATA
  unsigned long buffer_size;
#endif

  p = buf;
  ep = p + size;
  while (p < ep) {
    cmd = *(unsigned int *)p;
    p += sizeof(cmd);

    switch (cmd) {
      case BR_NOOP:
      case BR_TRANSACTION_COMPLETE:
        break;

      case BR_INCREFS:
      case BR_ACQUIRE:
      case BR_RELEASE:
      case BR_DECREFS:
        fprintf(stderr, "client %d received unexpected ref_cmd command\n", id);
        if (p + 2 * sizeof(cmd) > ep) {
          fprintf(stderr, "client %d not enough ref_cmd data\n", id);
          return -1;
        }
        p += 2 * sizeof(cmd);
        break;

      case BR_TRANSACTION:
        fprintf(stderr, "client %d received unexpected transaction command\n", id);
        if (p + sizeof(*tdata) > ep) {
          fprintf(stderr, "client %d: not enough transaction data\n", id);
          return -1;
        }

        tdata = (tdata_t *)p;
        p += sizeof(*tdata);
#ifdef INLINE_TRANSACTION_DATA
        buffer_size = ALIGN(tdata->data_size) + ALIGN(tdata->offsets_size);
        if (p + buffer_size > ep) {
          fprintf(stderr, "client %d: not enough transaction data buffer\n", id);
          return -1;
        }
        p += buffer_size;
#endif
        break;

      case BR_REPLY:
        if (p + sizeof(*tdata) > ep) {
          fprintf(stderr, "client %d: not enough transaction data\n", id);
          return -1;
        }

        tdata = (tdata_t *)p;
        p += sizeof(*tdata);
#ifdef INLINE_TRANSACTION_DATA
        buffer_size = ALIGN(tdata->data_size) + ALIGN(tdata->offsets_size);
        if (p + buffer_size > ep) {
          fprintf(stderr, "client %d: not enough transaction data buffer\n", id);
          return -1;
        }
        p += buffer_size;
#endif

        if (tdata->data_size != sizeof(inst_buf_t)) {
          fprintf(stderr, "client %d: data size in reply is incorrect\n", id);
          return -1;
        }
        if (inst) {
          fprintf(stderr, "client %d: received multiple reply\n", id);
          return -1;
        }
        inst = (inst_buf_t *)tdata->data.ptr.buffer;
        break;

      case BR_DEAD_BINDER:
        fprintf(stderr, "client %d received unexpected dead_binder command\n", id);
        if (p + sizeof(cmd) > ep) {
          fprintf(stderr, "client %d: not enough dead binder data\n", id);
          return -1;
        }

        p += sizeof(cmd);
        break;

      case BR_FAILED_REPLY:
        fprintf(stderr, "client %d received unexpected failed_reply command\n", id);
        return -1;

      case BR_DEAD_REPLY:
        fprintf(stderr, "client %d received unexpected dead_reply command\n", id);
        return -1;

      default:
        fprintf(stderr, "client %d received unknown command\n", id);
        return -1;
    }
  }

  if (p != ep) {
    fprintf(stderr, "client %d receiver buffer has unknown data\n", id);
    return -1;
  }

  *pinst = inst;
  return 0;
}

int client_main(void)
{
  int fd, r, n, m, wait = 0, retries;
  void *binder, *cookie;
  bcmd_txn_t *txn;
  bwr_t bwr;
  inst_buf_t *inst, *inst_reply;
  unsigned char rbuf[RBUF_SIZE];
  FILE *fp;

  fd = open("/dev/binder", O_RDWR);
  if (fd < 0) {
    fprintf(stderr, "client failed to open binder device\n");
    return -1;
  }

#if (!defined(INLINE_TRANSACTION_DATA))
  if (mmap(NULL, 128 * 1024, PROT_READ, MAP_PRIVATE, fd, 0) == MAP_FAILED) {
    fprintf(stderr, "server failed to mmap shared buffer\n");
    return -1;
  }
#endif

  while (1) {
    r = lookup_service(fd, service, sizeof(service) / 2, &binder, &cookie);
    if (r < 0) {
      fprintf(stderr, "client failed to find the instrumentation service\n" );
      return -1;
    } else if (r > 0)
      break;

    if (wait++ > 1)
      fprintf(stderr, "client still waiting on instrumentation service to be ready\n");
    sleep(1);
  }
  printf("client found instrumentation service\n");

  txn = create_transaction(0, binder, cookie, 0, NULL, sizeof(inst_buf_t), NULL, 0);
  if (!txn) {
    fprintf(stderr, "client failed to prepare transaction buffer\n");
    return -1;
  }

  bwr.write_buffer = (unsigned long)txn;
  bwr.read_buffer = (unsigned long)rbuf;

  inst = (inst_buf_t *)txn->tdata.data.ptr.buffer;
  //INST_INIT(inst);


  n = iterations + 1;
  while (n-- > 0) {

    retries = 2;

    bwr.write_size = sizeof(*txn);
    bwr.write_consumed = 0;
    bwr.read_size = sizeof(rbuf);
    bwr.read_consumed = 0;


wait_reply:
    r = ioctl(fd, BINDER_WRITE_READ, &bwr);
    if (r < 0) {
      fprintf(stderr, "client failed ioctl\n");
      return r;
    }
    r = client_parse_command(id, rbuf, bwr.read_consumed, &inst_reply);
    if (r < 0)
      return r;

    if (!inst_reply) {
      //hexdump(rbuf, bwr.read_consumed);
      if (retries-- > 0) {
        bwr.write_size = 0;
        bwr.read_consumed = 0;
        goto wait_reply;
      } else {
        fprintf(stderr, "client %d failed to receive reply\n", id);
        return -1;
      }
    }

    //result
    printf("[+] result = %c\n",inst_reply->data);
#if (defined(SIMULATE_FREE_BUFFER) || !defined(INLINE_TRANSACTION_DATA))
    if (FREE_BUFFER(fd, inst_reply) < 0) {
      fprintf(stderr, "client %d: failed to free shared buffer\n", id);
      return -1;
    }
#endif
  }


  return 0;
}


int main(int argc, char **argv)
{
  if(client_main()!=0)
    fprintf(stderr,"%s exit with error",argv[0]);
  return 0;
}
