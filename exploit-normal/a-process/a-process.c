#include "../lib/binder.h"

#define SVC_MAGIC           0x696e7374                                          
#define SVC_BINDER          ((void *)SVC_MAGIC)                                 
#define SVC_COOKIE          ((void *)SVC_MAGIC)                                 

static uint16_t service[] = { 'A', 's', 'v', 'r' };  


                                                  
int server_parse_command(unsigned char *buf, long size, tdata_t **tdata_out, bcmd_txn_t **txn_out)
{
    unsigned char *p, *ep;
    unsigned int cmd;
    tdata_t *tdata = NULL;
    bcmd_txn_t *txn = NULL;
#ifdef INLINE_TRANSACTION_DATA
    unsigned long buffer_size;
#endif

    p = buf;
    ep = p + size;
    while (p < ep) {
        cmd = *(unsigned int *)p;
        p += sizeof(cmd);

        switch (cmd) {
        case BR_NOOP:
        case BR_TRANSACTION_COMPLETE:
            break;

        case BR_INCREFS:
        case BR_ACQUIRE:
        case BR_RELEASE:
        case BR_DECREFS:
            fprintf(stderr, "server received unexpected ref_cmd command\n");
            if (p + 2 * sizeof(cmd) > ep) {
                fprintf(stderr, "server not enough ref_cmd data\n");
                return -1;
            }
            p += 2 * sizeof(cmd);
            break;

        case BR_TRANSACTION:
            if (p + sizeof(*tdata) > ep) {
                fprintf(stderr, "server not enough transaction data\n");
                return -1;
            }

            tdata = (tdata_t *)p;
            p += sizeof(*tdata);

            if (tdata->data_size != sizeof(inst_buf_t)) {
                fprintf(stderr, "server data size in transaction is incorrect\n");
                return -1;
            }

#ifdef INLINE_TRANSACTION_DATA
            buffer_size = ALIGN(tdata->data_size) + ALIGN(tdata->offsets_size);
            if (p + buffer_size > ep) {
                fprintf(stderr, "server not enough transaction data buffer\n");
                return -1;
            }

            txn = (bcmd_txn_t *)(p - sizeof(*tdata) - sizeof(cmd));
            txn->cmd = BC_REPLY;

            p += buffer_size;
#else
            txn = create_transaction(1, NULL, NULL, 0,
                                     (unsigned char *)tdata->data.ptr.buffer, tdata->data_size,
                                     (unsigned char *)tdata->data.ptr.offsets, tdata->offsets_size);
            if (!txn) {
                fprintf(stderr, "server failed to create reply buffer\n");
                return -1;
            }
#endif

            goto expected_out;

        case BR_REPLY:
            fprintf(stderr, "server received unexpected reply command\n");
            if (p + sizeof(*tdata) > ep) {
                fprintf(stderr, "server not enough transaction data\n");
                return -1;
            }

            tdata = (tdata_t *)p;
            p += sizeof(*tdata);

#ifdef INLINE_TRANSACTION_DATA
            buffer_size = ALIGN(tdata->data_size) + ALIGN(tdata->offsets_size);
            if (p + buffer_size > ep) {
                fprintf(stderr, "server not enough transaction data buffer\n");
                return -1;
            }
            p += buffer_size;
#endif
            break;

        case BR_DEAD_BINDER:
            fprintf(stderr, "server received unexpected dead_binder command\n");
            if (p + sizeof(cmd) > ep) {
                fprintf(stderr, "server not enough dead binder data\n");
                return -1;
            }

            p += sizeof(cmd);
            break;

        case BR_FAILED_REPLY:
            fprintf(stderr, "server received unexpected failed_reply command\n");
            return -1;

        case BR_DEAD_REPLY:
            fprintf(stderr, "server received unexpected dead_reply command\n");
            return -1;

        default:
            fprintf(stderr, "server received unknown command\n");
            return -1;
        }
    }

expected_out:
    *tdata_out = tdata;
    *txn_out = txn;
    return (p - buf);
}

int server_main(void)
{
    int fd, r, len;
    void *binder, *cookie;
    bwr_t bwr;
    unsigned char rbuf[RBUF_SIZE], *p;
    bcmd_txn_t *reply;
    tdata_t *tdata = NULL;
    inst_buf_t *inst;

    fd = open("/dev/binder", O_RDWR);
    if (fd < 0) {
        fprintf(stderr, "failed to open binder device\n");
        return -1;
    }

#if (!defined(INLINE_TRANSACTION_DATA))
    if (mmap(NULL, 128 * 1024, PROT_READ, MAP_PRIVATE, fd, 0) == MAP_FAILED) {
        fprintf(stderr, "server failed to mmap shared buffer\n");
        return -1;
    }
#endif

    binder = SVC_BINDER;
    cookie = SVC_COOKIE;

    r = add_service(fd, binder, cookie, service, sizeof(service) / 2);
    if (r < 0) {
        printf("server failed to add instrumentation service\n");
        return -1;
    }
    printf("server added instrumentation service\n");

    r = start_looper(fd);
    if (r < 0) {
        printf("server failed to start looper\n");
        return -1;
    }

    bwr.read_buffer = (unsigned long)rbuf;
    while (1) {
        bwr.read_size = sizeof(rbuf);
        bwr.read_consumed = 0;
        bwr.write_size = 0;

        r = ioctl(fd, BINDER_WRITE_READ, &bwr);
        if (r < 0) {
            fprintf(stderr, "server failed ioctl\n");
            return r;
        }
        //INST_RECORD(&copy);

        p = rbuf;
        len = bwr.read_consumed;
        while (len > 0) {
            r = server_parse_command(p, len, &tdata, &reply);
            if (r < 0)
                return r;

            p += r;
            len -= r;

#if (defined(SIMULATE_FREE_BUFFER) || !defined(INLINE_TRANSACTION_DATA))
            if (tdata)
                FREE_BUFFER(fd, (void *)tdata->data.ptr.buffer);
#endif
            if (!reply) {
                //hexdump(rbuf, bwr.read_consumed);
                continue;
            }

            inst = (inst_buf_t *)reply->tdata.data.ptr.buffer;
            inst->data = 'A';
            //INST_ENTRY_COPY(inst, "S_RECV", &copy);

            bwr.write_buffer = (unsigned long)reply;
            bwr.write_size = sizeof(*reply);
            bwr.write_consumed = 0;
            bwr.read_size = 0;

            //INST_ENTRY(inst, "S_REPLY");

            r = ioctl(fd, BINDER_WRITE_READ, &bwr);
            if (r < 0) {
                fprintf(stderr, "server failed reply ioctl\n");
                return r;
            }

#if (!defined(INLINE_TRANSACTION_DATA))
            free(reply);
#endif
        }
    }

    free(reply);
    return 0;
}

int main(int argc, char **argv)
{
   server_main();
    return 0;
}
