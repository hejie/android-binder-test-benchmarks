#include "binder.h"

void hexdump(const void *buf, unsigned long size)
{
    int col = 0, off = 0;
    unsigned char *p = (unsigned char *)buf;

    while (size--) {
        if (!col)
            printf("\t%08x:", off);

        printf(" %02x", *p++);

        off++;
        col++;

        if (!(col % 16)) {
            printf("\n");
            col = 0;
        } else if (!(col % 4))
            printf("  ");
    }

    if (col % 16)
        printf("\n\n");
    else
        printf("\n");
}

bcmd_txn_t *create_transaction(int reply,
                               void *binder, void *cookie, unsigned int code,
                               unsigned char *data, unsigned int data_size, unsigned char *offsets, unsigned int offsets_size)
{
    bcmd_txn_t *txn;
    tdata_t *tdata;
    unsigned char *p;
    unsigned int size, data_off = 0, offsets_off = 0;

    size = ALIGN(sizeof(*txn));
    if (data_size > 0) {
        data_off = size;
        size += ALIGN(data_size);

        if (offsets_size > 0) {
            offsets_off = size;
            size += ALIGN(offsets_size);
        }
    }

    p = malloc(size);
    if (!p)
        return NULL;

    txn = (bcmd_txn_t *)p;
    txn->cmd = reply ? BC_REPLY : BC_TRANSACTION;

    tdata = &txn->tdata;
    memset(tdata, 0, sizeof(*tdata));
    tdata->target.ptr = binder;
    tdata->cookie = cookie;
    tdata->code = code;

    if (data_size > 0) {
        if (data)
            memcpy(p + data_off, data, data_size);
        tdata->data.ptr.buffer = p + data_off;
        tdata->data_size = data_size;

        if (offsets_size > 0) {
            if (offsets)
                memcpy(p + offsets_off, offsets, offsets_size);
            tdata->data.ptr.offsets = p + offsets_off;
            tdata->offsets_size = offsets_size;
        }
    }

    return txn;
}

#if (defined(SIMULATE_FREE_BUFFER) || !defined(INLINE_TRANSACTION_DATA))
int FREE_BUFFER(int fd, void *ptr)
{
    bwr_t bwr;
    uint32_t cmd[2];

    cmd[0] = BC_FREE_BUFFER;
    cmd[1] = (uint32_t)ptr;

    memset(&bwr, 0, sizeof(bwr));
    bwr.write_buffer = (unsigned long)cmd;
    bwr.write_size = sizeof(cmd);

    return ioctl(fd, BINDER_WRITE_READ, &bwr);
}
#endif

int parse_command(void *buf, unsigned long size, tdata_t **reply)
{
    unsigned char *p, *ep;
    unsigned int cmd;
    tdata_t *tdata = NULL;
#ifdef INLINE_TRANSACTION_DATA
    unsigned long buffer_size;
#endif

    p = buf;
    ep = p + size;
    while (p < ep) {
        cmd = *(unsigned int *)p;
        p += sizeof(cmd);

        switch (cmd) {
        case BR_NOOP:
        case BR_TRANSACTION_COMPLETE:
            break;

        case BR_INCREFS:
        case BR_ACQUIRE:
        case BR_RELEASE:
        case BR_DECREFS:
            if (p + 2 * sizeof(cmd) > ep) {
                fprintf(stderr, "not enough ref_cmd data\n");
                return -1;
            }
            p += 2 * sizeof(cmd);
            break;

        case BR_TRANSACTION:
            fprintf(stderr, "rcv transaction\n");
            if (p + sizeof(*tdata) > ep) {
                fprintf(stderr, "not enough transaction data\n");
                return -1;
            }

            tdata = (tdata_t *)p;
            p += sizeof(*tdata);
#ifdef INLINE_TRANSACTION_DATA
            buffer_size = ALIGN(tdata->data_size) + ALIGN(tdata->offsets_size);
            if (p + buffer_size > ep) {
                fprintf(stderr, "not enough transaction data buffer\n");
                return -1;
            }
            p += buffer_size;
#endif
            tdata = NULL;
            break;

        case BR_REPLY:
            if (p + sizeof(*tdata) > ep) {
                fprintf(stderr, "not enough transaction data\n");
                return -1;
            }

            tdata = (tdata_t *)p;
            p += sizeof(*tdata);
#ifdef INLINE_TRANSACTION_DATA
            buffer_size = ALIGN(tdata->data_size) + ALIGN(tdata->offsets_size);
            if (p + buffer_size > ep) {
                fprintf(stderr, "not enough transaction data buffer\n");
                return -1;
            }
            p += buffer_size;
#endif
            goto expected_out;

        case BR_DEAD_BINDER:
            fprintf(stderr, "rcv DEAD_BINDER\n");
            if (p + sizeof(cmd) > ep) {
                fprintf(stderr, "not enough dead binder data\n");
                return -1;
            }

            p += sizeof(cmd);
            break;

        case BR_FAILED_REPLY:
            fprintf(stderr, "rcv FAILED_BINDER\n");
            return -1;

        case BR_DEAD_REPLY:
            fprintf(stderr, "rcv DEAD_BINDER\n");
            return -1;

        default:
            fprintf(stderr, "rcv unknown command: %u\n", cmd);
            return -1;
        }
    }

expected_out:
    *reply = tdata;
    return p - (unsigned char *)buf;
}

int simple_transact(int fd, bcmd_txn_t *txn, tdata_t **preply, unsigned char *buf, unsigned int size)
{
    bwr_t bwr;
    tdata_t *reply = NULL;
    int r, retries = 2;

    bwr.write_buffer = (unsigned long)txn;
    bwr.write_size = sizeof(*txn);
    bwr.write_consumed = 0;

wait_reply:
    bwr.read_buffer = (unsigned long)buf;
    bwr.read_size = size;
    bwr.read_consumed = 0;

    r = ioctl(fd, BINDER_WRITE_READ, &bwr);
    if (r < 0)
        return r;

    if (bwr.read_consumed > 0) {
        r = parse_command(buf, bwr.read_consumed, &reply);
        if (r < 0)
            return r;
    }

    if (reply) {
        *preply = reply;
        return 0;
    }

    if (retries-- <= 0) {
        fprintf(stderr, "no reply received\n");
        return -1;
    }

    bwr.write_size = 0;
    goto wait_reply;
}

int add_service(int fd, void *binder, void *cookie, uint16_t *name, int len)
{
    unsigned char buf[1024], *p;
    obj_t *obj;
    size_t *offsets;
    bcmd_txn_t *txn;
    tdata_t *tdata;
    int r;

    p = buf;

    // strict_policy
    *(uint32_t *)p = 0;
    p += 4;

    // svcmgr_id
    *(uint32_t *)p = sizeof(svcmgr_id) / 2;
    p += 4;
    memcpy(p, svcmgr_id, sizeof(svcmgr_id));
    p += sizeof(svcmgr_id);
    *(uint16_t *)p = 0;
    p += 2;
    p = (unsigned char *)ALIGN((unsigned long)p);

    // name
    *(uint32_t *)p = len;
    p += 4;
    memcpy(p, name, len * 2);
    p += len * 2;
    *(uint16_t *)p = 0;
    p += 2;
    p = (unsigned char *)ALIGN((unsigned long)p);

    // flat_binder_obj
    obj = (obj_t *)p;
    obj->type = BINDER_TYPE_BINDER;
    obj->flags = 0;
    obj->binder = binder;
    obj->cookie = cookie;
    p = (unsigned char *)(obj + 1);

    // offsets
    offsets = (size_t *)p;
    *offsets = (unsigned char *)obj - buf;

    txn = create_transaction(0, NULL, NULL, 3, buf, p - buf, (unsigned char *)offsets, 4);
    if (!txn)
        return -1;

    r = simple_transact(fd, txn, &tdata, buf, sizeof(buf));
    if (r < 0)
        return r;

    if (tdata->data_size != 4 || *(unsigned int *)tdata->data.ptr.buffer) {
        fprintf(stderr, "server invalid reply data received\n");
        return -1;
    }

#if (defined(SIMULATE_FREE_BUFFER) || !defined(INLINE_TRANSACTION_DATA))
    if (FREE_BUFFER(fd, (void *)tdata->data.ptr.buffer) < 0) {
        fprintf(stderr, "failed to free shared buffer\n");
        return -1;
    }
#endif
    free(txn);
    return 0;
}

int start_looper(int fd)
{
    bwr_t bwr;
    uint32_t cmd[1];

    cmd[0] = BC_ENTER_LOOPER;

    memset(&bwr, 0, sizeof(bwr));
    bwr.write_buffer = (unsigned long)cmd;
    bwr.write_size = sizeof(cmd);

    return ioctl(fd, BINDER_WRITE_READ, &bwr);
}

int lookup_service(int fd, uint16_t *name, int len, void **binder, void **cookie)
{
    unsigned char buf[1024], *p;
    obj_t *obj;
    bcmd_txn_t *txn;
    tdata_t *tdata;
    int r;

    p = buf;

    // strict_policy
    *(uint32_t *)p = 0;
    p += 4;

    // svcmgr_id
    *(uint32_t *)p = sizeof(svcmgr_id) / 2;
    p += 4;
    memcpy(p, svcmgr_id, sizeof(svcmgr_id));
    p += sizeof(svcmgr_id);
    *(uint16_t *)p = 0;
    p += 2;
    p = (unsigned char *)ALIGN((unsigned long)p);

    // name
    *(uint32_t *)p = len;
    p += 4;
    memcpy(p, name, len * 2);
    p += len * 2;
    *(uint16_t *)p = 0;
    p += 2;
    p = (unsigned char *)ALIGN((unsigned long)p);

    txn = create_transaction(0, NULL, NULL, 1, buf, p - buf, NULL, 0);
    if (!txn)
        return -1;

    r = simple_transact(fd, txn, &tdata, buf, sizeof(buf));
    if (r < 0)
        return r;

    if (tdata->data_size == 4 && !*(unsigned int *)tdata->data.ptr.buffer)
        return 0;	// server not ready

    if (tdata->data_size != sizeof(*obj) || tdata->offsets_size != 4) {
//fprintf(stderr, "client %d invalid reply data received\n", id);
        fprintf(stderr, "client invalid reply data received\n");
        return -1;
    }
    obj = (obj_t *)((unsigned char *)tdata->data.ptr.buffer + *(unsigned int *)tdata->data.ptr.offsets);
    if (obj->type != BINDER_TYPE_HANDLE) {
        //fprintf(stderr, "client %d invalid object type received\n", id);
        fprintf(stderr, "client invalid object type received\n");
        return -1;
    }
    *binder = obj->binder;
    *cookie = obj->cookie;

    free(txn);
    return 1;
}

